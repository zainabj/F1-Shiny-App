{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 107,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "\n",
    "drivers_raw = pd.read_csv('drivers.csv')\n",
    "results_raw = pd.read_csv('results.csv')\n",
    "races_raw_df = pd.read_csv('races.csv')\n",
    "driver_st_raw = pd.read_csv('driver_standings.csv')\n",
    "constructors_raw=pd.read_csv('constructor_standings.csv')\n",
    "\n",
    "def podium_counter(pos):\n",
    "    if pos in ['1', '2', '3']:\n",
    "        return True\n",
    "    else:\n",
    "        return False\n",
    "\n",
    "def win_counter(pos):\n",
    "    if pos == '1':\n",
    "        return True\n",
    "    else:\n",
    "        return False\n",
    "    \n",
    "def pole_counter(grid):\n",
    "    if grid == 1:\n",
    "        return True\n",
    "    else:\n",
    "        return False\n",
    "    \n",
    "results_copy = results_raw[['raceId', 'driverId','constructorId', 'grid', 'position', 'points', 'laps', 'rank']].copy().rename(\n",
    "    columns = {'rank':'fastlap'})\n",
    "\n",
    "# Adding podium, win, pole and fastest lap columns\n",
    "results_copy['podium'] = results_copy.position.apply(podium_counter)\n",
    "results_copy['win'] = results_copy.position.apply(win_counter)\n",
    "results_copy['pole'] = results_copy.grid.apply(pole_counter)\n",
    "results_copy['fastestLap'] = results_copy.fastlap.apply(win_counter)\n",
    "\n",
    "# Gouping with respect to drivers \n",
    "driver_stats_1 = results_copy.drop(columns = ['position', 'grid', 'fastlap']).groupby('driverId')\n",
    "func_dic = {'raceId':'count', 'points':'sum', 'laps':'sum', 'podium':'sum', 'win':'sum', 'pole':'sum', 'fastestLap':'sum'}\n",
    "driver_stats_1 = driver_stats_1.aggregate(func_dic).reset_index().rename(columns = {'raceId':'races'})\n",
    "\n",
    "# Gouping with respect to constuctors \n",
    "constr_stats_1 = results_copy.drop(columns = ['position', 'grid', 'fastlap']).groupby('constructorId')\n",
    "constr_stats_1 = constr_stats_1.aggregate(func_dic).reset_index().rename(columns = {'raceId':'races'})\n",
    "\n",
    "races_raw_df = races_raw_df.sort_values('date')\n",
    "races_df = races_raw_df[races_raw_df.date <= '2021-08-08']\n",
    "races_completed = len(races_df)\n",
    "idx = races_df.groupby(['year'])['date'].transform(max) == races_df['date'] # Finds if the race index is last of the season\n",
    "season_finale = races_df[idx].rename(columns = {'round' : 'tot_races'}) \n",
    "#season_finale = season_finale[season_finale.year != 2021] # excluding the 2021 season\n",
    "\n",
    "# Getting driver championship data\n",
    "driver_st_raw = pd.read_csv('driver_standings.csv')\n",
    "driver_st_season_end = season_finale[['raceId', 'year', 'tot_races']].merge(driver_st_raw, on = 'raceId')\n",
    "driver_champ = driver_st_season_end[driver_st_season_end['position'] == 1]\n",
    "driver_champ_tot = driver_champ[['driverId', 'position']].groupby('driverId').sum().reset_index().merge(\n",
    "    drivers_raw[['forename', 'surname', 'driverId']]).rename(\n",
    "    columns={'position':'titles'}).sort_values('titles', ascending = False)\n",
    "\n",
    "# Merging everthing to a single dataframe\n",
    "driver_stats = driver_stats_1.merge(driver_champ_tot[['driverId', 'titles']], how = 'left').fillna(0)\n",
    "driver_stats = drivers_raw[['driverId', 'forename', 'surname', 'nationality']].merge(driver_stats, on = 'driverId')\n",
    "\n",
    "# Merging everthing to a single dataframe\n",
    "driver_stats = driver_stats_1.merge(driver_champ_tot[['driverId', 'titles']], how = 'left').fillna(0)\n",
    "driver_stats = drivers_raw[['driverId', 'forename', 'surname', 'nationality']].merge(driver_stats, on = 'driverId')\n",
    "driver_stats['driver name']= driver_stats['forename']+ ' '+ driver_stats['surname']\n",
    "driver_stats= driver_stats[['driverId','driver name','nationality', 'races', 'points',\n",
    "       'laps', 'podium', 'win', 'pole', 'fastestLap', 'titles']]\n",
    "driver_stats.sort_values(by=['titles','win','podium'], inplace=True, ascending=False)\n",
    "\n",
    "#constructors\n",
    "constructor_st_season_end = season_finale[['raceId', 'year', 'tot_races']].merge(constructors_raw, on = 'raceId')\n",
    "constructors_name_raw=pd.read_csv('constructors.csv')\n",
    "constructor_champ = constructor_st_season_end[constructor_st_season_end['position'] == 1]\n",
    "constructor_champ_tot = constructor_champ[['constructorId', 'position','points','wins']].groupby('constructorId').sum().reset_index().merge(constructors_name_raw[['name', 'nationality','constructorId']], on ='constructorId').rename(\n",
    "    columns={'position':'titles'}).sort_values('titles', ascending = False)\n",
    "\n",
    "driver_stats.to_csv('championship.csv')\n",
    "constructor_champ_tot.to_csv('constructor_championship.csv')"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
